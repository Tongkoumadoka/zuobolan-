### 1.函数的两种定义方式

#首先,使用不带括号的函数名调用的是变量,而非调用函数

```
function sun () {
	sun = 10;
}

var num1 = sun; //调用的是函数名,把指针存到了num1中
```

#区别两种函数声明

```
实际上变量的方法就和赋值变量没什么区别,只是赋值了一个函数这种对象类型给变量
```

![image-20210607170858591](C:\Users\inui\AppData\Roaming\Typora\typora-user-images\image-20210607170858591.png)



#### 1.1在两种函数定义

- 函数声明
- 函数表达式接收匿名函数

==函数声明==:

```javascript
function fn () {
	//函数体
}
```

​	对于函数声明来说,它给这个普通函数名字 f

==匿名函数==:

```javascript
//把函数名称去掉,就是匿名函数
function () {
	//函数体
}
//但是这样的声明会直接报错
```

#### 1.2匿名函数用法

==匿名函数的用法:==

##### (1)匿名函数的应用场景

- 事件

  给事件添加触发后的函数操作

```javascript
<input type="button" value="点我啊！" id="sub">

<script>

    //获得按钮元素

    var sub=document.querySelector("#sub");

    //给按钮增加点击事件。

    sub.onclick=function(){

        alert("当点击按钮时会执行到我哦！");

    }

</script>
```

- 对象

给对象添加方法: 用键值对的方式 

```javascript
var obj={

    name:"张培跃",

    age:18,

    fn:function(){

        return "我叫"+this.name+"今年"+this.age+"岁了！";

    }

};
```

- 函数表达式

把匿名函数赋值给变量fn ,存储一个function类型的数据对象

```javascript
var fn=function(){

    return "我是一只小小小小留下，怎么飞也飞不高！"

}
```

- 回调函数

```javascript
setInterval(function(){

    console.log("我其实是一个回调函数，每次1秒钟会被执行一次");

},1000);

//其实用箭头函数也可以
setInterval(()=>{

    console.log("我其实是一个回调函数，每次1秒钟会被执行一次");

},1000);
```

- 返回值

直接把匿名函数作为返回值

```javascript
function fn(){

    //返回匿名函数

    return function(){

        return "张培跃";

    }

}
```

###### 结论:

匿名函数本质就是一个(坨)值,就好像数值 10 ,字符串 'abc'一样,要么你直接用掉它,要么你找个变量存储它再使用

**把它的基本用法完全代入到基本数据类型的用法即可**

##### (2)匿名函数模仿块级作用域--==实现闭包==



### 2.箭头函数的用法

#### 2.1基本用法

```javascript
(param1, param2, …, paramN) => { statements }
//等价于
(param1, param2, …, paramN) => { return expression; }

//情况1 没有参数时 : 必须加小括号()
() => { statements }

//情况2 参数为1个时 : 可加可不加()
(param1) => { statements }
 param1 => { statements }

 //情况3 参数2个以上 : 必须加()
 
 //结论1: 为了防止出错,参数一定加小括号
 
 //情况 4 删除大括号,意味着不进行return返回值
 (param1, param2, …, paramN) => statements

 //情况 5 返回单个对象,必须在函数体外加()
 x => ({ foo: x })
 // 因为 对象的{}和函数体{}冲突
```

箭头函数的应用场景绝大部分和匿名函数差不多,你可以当成简化的匿名函数

但是也有区别

#### 2.2和匿名函数的区别

在于this的词法作用域

箭头函数会继承上一层函数的指向对象

### 3.回调函数的用法

### 4.函数作用域和作用域链

#### 4.1分类:

全局作用域:全局命名,全局调用

局部作用域:函数内部{},外部是无法简单访问到内部变量和方法的(本质上js就是函数作用域)



#### 4.2注意原则

1.函数内部局部变量声明需要用==var== 用let,或者不写等于声明了全局变量

2.函数内部(局部变量)会有变量==声明提前hoist==,函数调用的话会先找局部作用域看有没有,如果都没有再找全局变量

3.JS**并没有块级作用域**,==使用函数作用域== for{},if{}内声明的变量还是全局可见的

不像c语言,他们固定在语句中不可以被外部调用

4.在函数体内，局部变量的优先级高于同名的全局变量

#### 4.3执行环境和链式查找

函数对象和其它对象一样，拥有可以通过代码访问的属性和一系列仅供JavaScript引擎访问的内部属性。

其中一个==内部属性[[Scope]]==，由ECMA-262标准第三版定义，该内部属性包含了函数被创建的作用域中所有==对象的集合==，这个集合被称为==函数的作用域链==，它决定了哪些数据能被函数访问。

[[scope]]作为一个函数对象的内部属性,我们无法外部访问

执行此函数时会创建一个称为“运行期上下文(execution context)”的内部对象

- 运行期上下文 --是一个对象,内部对象!!! 
- 它在函数执行时被创建
- 同时创建当前函数的 活动对象 activation object
- 还有一开始就存在的 全局对象 global object

![image-20210615133950019](C:\Users\inui\AppData\Roaming\Typora\typora-user-images\image-20210615133950019.png)

